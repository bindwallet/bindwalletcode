/*
 * dop@0.26.2
 * www.distributedobjectprotocol.org
 * (c) 2016 Josema Gonzalez
 * MIT License.
 */

//////////  src/dop.js
(function factory(root) {

var dop = {
    name: 'dop',
    version: '0.26.2',
    create: factory,

    // Internal data
    data: {
        node_inc: 0,
        node: {},

        object_inc: 1,
        object: {},

        collectors: [],

        gets_collecting: false,
        gets_paths: [],

        computed_inc: 0,
        computed: {},

        observers_inc: 0,
        observers: {},

        path: {
            // "1.thepath.value": {
                // observers: {},
                // observers_prop: {},
                // interceptors: {},
                // interceptors_prop: {},
                // computeds: [],
                // derivations: [],
            // }
        }
    },
    
    // src
    util: {},
    core: {},
    protocol: {},
    transports: {listen:{}, connect:{}},

    // Constants
    cons: {
        TOKEN: '~TOKEN_DOP',
        DOP: '~DOP',
        // CONNECT: '~CONNECT',
        SEND: '~SEND',
        DISCONNECT: '~DISCONNECT',
        REMOTE_FUNCTION: '$DOP_REMOTE_FUNCTION',
        REMOTE_FUNCTION_UNSETUP: '$DOP_REMOTE_FUNCTION_UNSETUP',
        BROADCAST_FUNCTION: '$DOP_BROADCAST_FUNCTION',
        COMPUTED_FUNCTION: '$DOP_COMPUTED_FUNCTION',
    }

};





//////////  src/env/browser/connect.js

dop.connect = function(options) {

    var args = Array.prototype.slice.call(arguments, 0);

    if (dop.util.typeof(args[0]) != 'object')
        options = args[0] = {};

    if (typeof options.transport != 'function')
        options.transport = dop.transports.connect.websocket;

    return dop.core.connector(args);
};




//////////  src/env/browser/emitter.js

dop.util.emitter = function() {
    this._events = {};
};


dop.util.emitter.prototype.on = function(name, callback, once) {
    if (isFunction(callback)) {
        if (!isObject(this._events))
            this._events = {};
        if (!isObject(this._events[name]))
            this._events[name] = [];
        this._events[name].push(
            (once === true) ? [ callback, true ] : [ callback ]
       );
    }
    return this;
};



dop.util.emitter.prototype.once = function(name, callback) {
    return this.on(name, callback, true);
};



dop.util.emitter.prototype.emit = function(name) {
    if (isObject(this._events[name]) && this._events[name].length > 0) {
        for (var i=0, fun=[], args=Array.prototype.slice.call(arguments, 1); i < this._events[name].length; i++) {
            fun.push(this._events[name][i][0]);
            if (this._events[name][i][1] === true) {
               this._events[name].splice(i, 1); 
               i -= 1;
            }
        }
        for (i=0; i < fun.length; i++)
            fun[i].apply(this, args);
    }
    return this;
};




dop.util.emitter.prototype.removeListener = function(name, callback) {
    if (isObject(this._events[name]) && this._events[name].length > 0) {
        for (var i=0; i < this._events[name].length; i++) {
            if (this._events[name][i][0] === callback) {
                this._events[name].splice(i, 1); 
                i -= 1;
            }
        }
    }
    return this;
};




/*
name = 'T@!#asty ';
emitter = new require('events').EventEmitter();
emitter = new dop.util.emitter();

emitter.on(name, function() {
    console.log('AAA', arguments.length); 
})

cached = function() { console.log('BBB',this._events[name].length); emitter.removeListener(name, cached) };
emitter.on(name, cached);
emitter.on(name, cached);

emitter.once(name, function() {
    console.log('CCC', this._events[name].length); 
})


emitter.emit(name);
emitter.emit(name, 2, 3);
emitter.emit(name, 4);
*/




//////////  src/env/browser/listen.js

dop.listen = function(options) {

    var args = Array.prototype.slice.call(arguments, 0);

    if (dop.util.typeof(args[0]) != 'object')
        options = args[0] = {};

    if (typeof options.transport != 'function')
        options.transport = dop.transports.listen.local;

    return new dop.core.listener(args);
};




//////////  src/env/browser/websocket.js
(function(root){
function websocket(dop, node, options) {

    var url = 'ws://localhost:4444/'+dop.name,
        oldSocket;

    if (typeof options.url == 'string')
        url = options.url.replace('http','ws');
    else if (typeof window!='undefined' && typeof window.location!='undefined' && /http/.test(window.location.href)) {
        var domain_prefix = /(ss|ps)?:\/\/([^\/]+)\/?(.+)?/.exec(window.location.href),
            protocol = domain_prefix[1] ? 'wss' : 'ws';
        url = protocol+'://'+domain_prefix[2].toLocaleLowerCase()+'/'+dop.name;
    }

    // Variables
    var api = options.transport.getApi(),
        socket = new api(url),
        tokenServer,
        send_queue = [],
        readyState;
    
    // Helpers
    function send(message) {
        (socket.readyState===OPEN) ?
            socket.send(message)
        :
            send_queue.push(message); 
    }
    function sendQueue() {
        if (socket.readyState===OPEN)
            while (send_queue.length>0)
                socket.send(send_queue.shift());
    }

    // Socket events
    function onopen() {
        // Reconnect
        if (readyState === CONNECTING)
            socket.send(tokenServer);
        // Connect
        else {
            socket.send(''); // Empty means we want to get connected
            readyState = OPEN;
        }
        dop.core.emitOpen(node, socket, options.transport);
    }
    function onmessage(message) {
        // console.log( 'C<<: `'+message.data+'`' );
        // Reconnecting
        if (readyState===CONNECTING && message.data===tokenServer) {
            readyState = CONNECT;
            dop.core.setSocketToNode(node, socket);
            dop.core.emitReconnect(node, oldSocket);
            sendQueue();
        }
        else if (readyState !== CONNECT) {
            tokenServer = message.data;
            readyState = CONNECT;
            dop.core.setSocketToNode(node, socket);
            send(tokenServer);
            sendQueue();
            dop.core.emitConnect(node);
        }
        else
            dop.core.emitMessage(node, message.data, message);
    }
    function onclose() {
        readyState = CLOSE;
        dop.core.emitClose(node, socket);
        dop.core.emitDisconnect(node);
    }

    // dop events
    // function onconnect() {
    //     if (readyState === CONNECTING) {
    //         dop.core.emitDisconnect(node);
    //         dop.core.setSocketToNode(node, socket);
    //     }
    //     readyState = CONNECT;
    //     dop.core.emitConnect(node);
    //     sendQueue();
    // }
    function ondisconnect() {
        readyState = CLOSE;
        socket.close();
    }

    function reconnect() {
        if (readyState === CLOSE) {
            oldSocket = socket;
            socket = new api(url);
            readyState = CONNECTING;
            addListeners(socket, onopen, onmessage, onclose);
            removeListeners(oldSocket, onopen, onmessage, onclose);
        }
    }

    // Setting up
    dop.core.setSocketToNode(node, socket);
    readyState = CLOSE;
    node.reconnect = reconnect;
    // node.on(dop.cons.CONNECT, onconnect);
    node.on(dop.cons.SEND, send);
    node.on(dop.cons.DISCONNECT, ondisconnect);
    addListeners(socket, onopen, onmessage, onclose);
    
    return socket;
}

function addListeners(socket, onopen, onmessage, onclose) {
    socket.addEventListener('open', onopen);
    socket.addEventListener('message', onmessage);
    socket.addEventListener('close', onclose);
}
function removeListeners(socket, onopen, onmessage, onclose) {
    socket.removeEventListener('open', onopen);
    socket.removeEventListener('message', onmessage);
    socket.removeEventListener('close', onclose);
}


// UMD
if (
    typeof module == 'object' &&
    module.exports &&
    !(typeof dop == 'object' && typeof factory == 'function' && dop.create === factory) // this is true if we are inside of dop.factory
)
    module.exports = websocket;
else {
    websocket.getApi = function() { return window.WebSocket };
    (typeof dop != 'undefined') ?
        dop.transports.connect.websocket = websocket
    :
        root.dopTransportsConnectWebsocket = websocket;
}

// Cons
var CLOSE = 0,
    OPEN = 1,
    CONNECTING = 2,
    CONNECT = 3;


})(this);




//////////  src/util/alias.js
// Private alias
function isFunction(func) {
    return typeof func == 'function';
}

function isObject(object) {
    return (object!==null && typeof object=='object');
}

function isArray(array) {
    return Array.isArray(array);
}

function isNumber(number) {
    return typeof number == 'number';
}




//////////  src/util/clone.js

dop.util.clone = function(value) {
    return (dop.isPojoObject(value)) ?
        dop.util.merge(isArray(value) ? [] : {}, value)
    :
        value;
};




//////////  src/util/get.js

dop.util.get = function(object, path) {

    if (path.length === 0)
        return object;

    for (var index=0, total=path.length, tmpobject; index<total; index++) {

        tmpobject = object[ path[index] ];

        if (index+1<total && isObject(tmpobject))
            object = tmpobject;

        else if (object.hasOwnProperty(path[index]))
            return tmpobject;

        else
            return undefined;

    }

    return object[ path[index] ];
};




// dop.util.set = function(object, path, value) {

//     if (path.length == 0)
//         return object;

//     path = path.slice(0);
//     var obj = object, objdeep, index=0, total=path.length-1;

//     for (;index<total; ++index) {
//         objdeep = obj[path[index]];
//         obj = (objdeep && typeof objdeep == 'object') ?
//             objdeep
//         :
//             obj[path[index]] = {};
//     }

//     obj[path[index]] = value;

//     return object;
// };

// /*
// ori = {test:{hs:124}}
// console.log( dop.util.set(ori, ['test','more'], undefined))
// */







//////////  src/util/invariant.js

dop.util.invariant = function(check) {
    if (!check) {
        var message = dop.util.sprintf.apply(this, Array.prototype.slice.call(arguments, 1));
        throw new Error("[dop] Invariant failed: " + message);
    }
};




//////////  src/util/merge.js

dop.util.merge = function(first, second) {
    var args = arguments;
    if (args.length > 2) {
        // Remove the first 2 arguments of the arguments and add thoose arguments as merged at the begining
        Array.prototype.splice.call(args, 0, 2, dop.util.merge.call(this, first, second));
        // Recursion
        return dop.util.merge.apply(this, args);
    }
    else {
        dop.util.path(second, this, first, dop.util.mergeMutator);
        if (isArray(second))
            first.length = second.length;
        return first;
    }
};

dop.util.mergeMutator = function(destiny, prop, value, typeofValue) {
    if (typeofValue=='object' || typeofValue=='array')
        (!destiny.hasOwnProperty(prop)) ? (destiny[prop] = (typeofValue=='array') ? [] : {}) : destiny[prop];
    else
        destiny[prop] = value;
};




//////////  src/util/path.js

dop.util.path = function (source, callback, destiny, mutator) {
    var hasCallback = isFunction(callback),
        hasDestiny = isObject(destiny);
    dop.util.pathRecursive(source, callback, destiny, mutator, [], [], hasCallback, hasDestiny);
    return destiny;
};

dop.util.pathRecursive = function (source, callback, destiny, mutator, circular, path, hasCallback, hasDestiny) {

    var prop, value, typeofValue, skip;

    for (prop in source) {

        skip = false;
        value = source[prop];
        path.push(prop);

        if (hasCallback)
            skip = callback(source, prop, value, destiny, path, this);

        if (skip !== true) {

            typeofValue = dop.util.typeof(value);

            if (hasDestiny)
                skip = mutator(destiny, prop, value, typeofValue, path);

            // Objects or arrays
            if (
                (typeofValue=='object' || typeofValue=='array') &&
                skip !== true && 
                value!==source && 
                circular.indexOf(value)==-1 &&
                (hasDestiny && destiny[prop]!==undefined)
            ) {
                circular.push(value);
                dop.util.pathRecursive(
                    value,
                    callback,
                    hasDestiny ? destiny[prop] : undefined,
                    mutator,
                    circular,
                    path,
                    hasCallback,
                    hasDestiny
                );
            }

            path.pop();
        }
    }
};




//////////  src/util/sprintf.js

dop.util.sprintf = function() {

    var s = -1, result, str=arguments[0], array = Array.prototype.slice.call(arguments, 1);
    return str.replace(/"/g, "'").replace(/%([0-9]+)|%s/g , function() {

        result = array[ 
            (arguments[1] === undefined || arguments[1] === '') ? ++s : arguments[1]
        ];

        if (result === undefined)
            result = arguments[0];

        return result;

    });

};
// Usage: sprintf('Code error %s for %s', 25, 'Hi') -> "Code error 25 for Hi"
// Usage2: sprintf('Code error %1 for %0', 25, 'Hi') -> "Code error Hi for 25"




//////////  src/util/swap.js

dop.util.swap = function(array, swaps, callback) {

    if (array.length>0 && swaps.length>1) {

        var index = 0,
            total = swaps.length-1,
            tempItem, swapA, swapB,
            isCallback = isFunction(callback);

        for (;index<total; index+=2) {
            swapA = swaps[index];
            swapB = swaps[index+1];
            tempItem = array[swapA];
            array[swapA] = array[swapB];
            array[swapB] = tempItem;
            if (isCallback)
                callback(swapA, swapB);
        }
    }

     return array;
};




//////////  src/util/typeof.js
// https://jsperf.com/typeof-with-more-types
// dop={util:{}}
dop.util.typeof = function(value) {
    var s = typeof value;
    if (s == 'object') {
        if (value) {
            if (isArray(value))
                s = 'array';
            else if (value instanceof Date)
                s = 'date';
            else if (value instanceof RegExp)
                s = 'regexp';
        }
        else
            s = 'null';
    }
    return s;
};



// dop.util.typeof2 = (function() {
    
//     var list = {

//         '[object Null]': 'null',
//         '[object Undefined]': 'undefined',
//         '[object Object]': 'object',
//         '[object Function]': 'function',
//         '[object Array]': 'array',
//         '[object Number]': 'number',
//         '[object String]': 'string',
//         '[object Boolean]': 'boolean',
//         '[object Symbol]': 'symbol',
//         '[object RegExp]': 'regexp',
//         '[object Date]': 'date'
//     };


//     return function(type) {

//         return list[ Object.prototype.toString.call(type) ];

//     };


// })();

// Typeof=dop.util.typeof;
// console.log(Typeof(null));
// console.log(Typeof(undefined));
// console.log(Typeof({}));
// console.log(Typeof(function(){}));
// console.log(Typeof([]));
// console.log(Typeof(1));
// console.log(Typeof("s"));
// console.log(Typeof(true));
// console.log(Typeof(/a/));
// console.log(Typeof(new Date()));
// console.log(Typeof(Symbol('')));
// console.log(Typeof(new Typeof));


// Typeof(null);
// Typeof(undefined);
// Typeof({});
// Typeof(function(){});
// Typeof([]);
// Typeof(1);
// Typeof("s");
// Typeof(true);
// Typeof(/a/);
// Typeof(new Date());
// Typeof(Symbol(''));
// Typeof(new Typeof);






//////////  src/util/uuid.js

dop.util.uuid = function () {

    for (var i=0, uuid='', random; i < 32; i++) {
        random = Math.random() * 16 | 0;
        if (i === 8 || i === 12 || i === 16 || i === 20)
            uuid += '-';
        uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
    }

    return uuid;
};




//////////  src/api/action.js

dop.action = function(func) {
    return function() {
        var collector = dop.collect();
        func.apply(this, arguments);
        collector.emit();
    }
};




//////////  src/api/collect.js

dop.collect = function(index_function) {
    dop.util.invariant(arguments.length==0 || (arguments.length==1 && isFunction(index_function)), 'dop.collect only accept one argument as function');
    var index = index_function ? index_function(dop.data.collectors) : dop.data.collectors.length;
    return dop.core.createCollector(dop.data.collectors, index);
};




//////////  src/api/computed.js

dop.computed = function(callback) {
    dop.util.invariant(isFunction(callback), 'dop.computed needs a function as first parameter');
    var f = function (object, property, shallWeSet, oldValue) {
        return dop.core.createComputed(object, property, callback, shallWeSet, oldValue);
    }
    f._name = dop.cons.COMPUTED_FUNCTION;
    return f;
};




//////////  src/api/createObserver.js

dop.createObserver = function(callback) {
    dop.util.invariant(isFunction(callback), 'dop.createObserver only accept one argument as function');
    var observers=dop.data.observers, index, observer_id, observer;
    for (index in observers)
        if (observers[index].callback === callback)
            return observers[index];

    observer_id = dop.data.observers_inc++;
    observer = new dop.core.observer(callback, observer_id);
    return observers[observer_id] = observer;
};




//////////  src/api/decode.js

dop.decode = function(data, node) {
    var undefineds = [],
        index = 0,
        total,
        output = JSON.parse(data, function(property, value) {
            return dop.core.decode.call(this, property, value, node, undefineds);
        });

    for (total=undefineds.length,index=0; index<total; ++index)
        undefineds[index][0][undefineds[index][1]] = undefined;

    return output;
};




//////////  src/api/del.js

dop.del = function(object, property) {
    // dop.util.invariant(dop.isRegistered(object), 'Object passed to dop.del must be a registered object');
    return (dop.isRegistered(object)) ?
        dop.core.delete(object, property) !== undefined
    :
        delete object[property];
};




//////////  src/api/encode.js

dop.encode = function(data, encoder) {
    if (typeof encoder != 'function')
        encoder = dop.core.encode;
    return JSON.stringify(data, encoder);
};
dop.encodeFunction = function(data) {
    return JSON.stringify(data, dop.core.encodeFunction);
};




//////////  src/api/get.js

dop.get = function(object, property) {
    // dop.util.invariant(dop.isRegistered(object), 'Object passed to dop.del must be a registered object');
    if (dop.data.gets_collecting && dop.isRegistered(object))
        dop.core.proxyObjectHandler.get(dop.getObjectTarget(object), property);

    return object[property];
};




//////////  src/api/getNodeBySocket.js

dop.getNodeBySocket = function(socket) {
    return dop.data.node[ socket[dop.cons.TOKEN] ];
};




//////////  src/api/getObject.js

dop.getObjectDop = function(object) {
    return object[dop.cons.DOP];
};

dop.getObjectRoot = function(object) {
    return dop.getObjectDop(object).r;
};

dop.getObjectParent = function(object) {
    return dop.getObjectDop(object)._;
};

dop.getObjectProxy = function(object) {
    return dop.getObjectDop(object).p;
};

dop.getObjectTarget = function(object) {
    return dop.getObjectDop(object).t;
};

dop.getObjectProperty = function(object) {
    var object_dop = dop.getObjectDop(object);
    if (isArray(object_dop._))
        dop.getObjectPath(object);
    return object_dop.pr;
};

dop.getObjectId = function(object) {
    return dop.getObjectProperty(dop.getObjectRoot(object));
};

dop.getObjectLevel = function(object) {
    return dop.getObjectDop(object).l;
};





// dop.getObjectId = function(object) {
//     var object_dop = dop.getObjectDop(object);
//     return object_dop ? object_dop[0] : undefined;
// };
// dop.getObjectProperty = function(object) {
//     var object_dop = dop.getObjectDop(object);
//     return object_dop[object_dop.length-1];
// };
// dop.getObjectRoot = function(object) {
//     while(dop.getObjectParent(object) !== undefined)
//         object = dop.getObjectParent(object);
//     return dop.getObjectProxy(object);
// };

// dop.getObjectRoot = function(object) {
//     return dop.data.object[dop.getObjectId(object)];
// };

// dop.getObjectRootById = function(object_id) {
//     return dop.data.object[object_id];
// };




//////////  src/api/getObjectPath.js

dop.getObjectPath = function(object, strict) {

    var path = [], 
        // path_id = '',
        parent,
        prop,
        object_dop = object[dop.cons.DOP];

    strict = strict !== false;    

    while (object_dop._ !== undefined) {
        prop = object_dop.pr;
        parent = dop.getObjectTarget(object_dop._);
        if (!strict || parent[prop] === object_dop.p) {
            path.unshift(prop);
            object_dop = parent[dop.cons.DOP];
            // path_id = dop.core.pathSeparator(prop)+path_id;
        }
        else {
            if (isArray(parent)) {
                prop = parent.indexOf(object_dop.p);
                if (prop === -1)
                    return;
                else
                    object_dop.pr = prop;
                    // path.unshift(prop);
            }
            else
                return;
        }
    }
    
    path.unshift(object_dop.pr);
    // path.path_id = dop.core.pathSeparator(object_dop.pr)+path_id;
    return path;
};


// dop.getObjectPathId = function(object) {
//     return dop.core.getPathId(dop.getObjectPath(object));
// };




//////////  src/api/intercept.js

dop.intercept = function(object, property, callback) {

    dop.util.invariant(dop.isRegistered(object), 'dop.intercept() needs a registered object as first parameter');
    var path = dop.getObjectPath(object);
    dop.util.invariant(isArray(path), 'dop.intercept() The object you are passing is not allocated to a registered object');
    var type = 'interceptors';
    if (arguments.length === 2)
        callback = property;
        
    dop.util.invariant(isFunction(callback), 'dop.intercept() needs a callback as last parameter');

    var path_id = dop.core.getPathId(path),
        data_path = dop.data.path;

    if (arguments.length === 3) {
        type = 'interceptors_prop';
        path_id += dop.core.pathSeparator(property);
    }

    if (data_path[path_id] === undefined)
        data_path[path_id] = {};

    if (data_path[path_id][type] === undefined)
        data_path[path_id][type] = [];

    var interceptors = data_path[path_id][type];
    interceptors.push(callback);

    return function dispose() {
        // delete interceptors[interceptors.indexOf(callback)]; // we splice in dop.core.runInterceptors
        interceptors.splice(interceptors.indexOf(callback), 1);
    };

};








//////////  src/api/isBroadcastFunction.js

dop.isBroadcastFunction = function(fun) {
    return (isFunction(fun) && fun._name===dop.cons.BROADCAST_FUNCTION);
};




//////////  src/api/isObjectRegistrable.js
dop.isObjectRegistrable = function(object) {
    return isObject(object);
};




//////////  src/api/isPojoObject.js
dop.isPojoObject = function(object) {
    if (object === null || typeof object !== "object") return false;
    var prototype = Object.getPrototypeOf(object);
    return prototype === Object.prototype || prototype === Array.prototype;
};


// dop.isPojoObject = function(object) {
//     var tof = dop.util.typeof(object);
//     return (tof === 'object' || tof == 'array');
// };

// function Test(){}
// console.log(dop.isPojoObject({}));
// console.log(dop.isPojoObject([]));
// console.log(dop.isPojoObject(new Error));
// console.log(dop.isPojoObject(new Date()));
// console.log(dop.isPojoObject(null));
// console.log(dop.isPojoObject(Symbol('')));
// console.log(dop.isPojoObject(function(){}));
// console.log(dop.isPojoObject(1));
// console.log(dop.isPojoObject("s"));
// console.log(dop.isPojoObject(true));
// console.log(dop.isPojoObject(/a/));




//////////  src/api/isRegistered.js

dop.isRegistered = function(object) {
    return (
        isObject(object) &&
        dop.getObjectDop(object) !== undefined &&
        !Object.getOwnPropertyDescriptor(object, dop.cons.DOP).enumerable
    );
};




//////////  src/api/isRemoteFunction.js

dop.isRemoteFunction = function(fun) {
    return (isFunction(fun) && fun._name===dop.cons.REMOTE_FUNCTION);
};




//////////  src/api/onsubscribe.js

dop.onSubscribe = function(callback) {
    dop.util.invariant(isFunction(callback), 'dop.onSubscribe only accept a function as parameter');
    dop.data.onsubscribe = callback;
};




//////////  src/api/register.js

dop.register = function(object) {
    dop.util.invariant(dop.isObjectRegistrable(object) && !isArray(object), 'dop.register needs an object or an array as first parameter');
    return (dop.isRegistered(object)) ?
        dop.getObjectProxy(object)
    :
        dop.core.configureObject(object, dop.data.object_inc++);
};





//////////  src/api/removeComputed.js

dop.removeComputed = function(object, property, callback) {
    dop.util.invariant(dop.isRegistered(object), 'dop.removeComputed needs a registered object as first parameter');
    dop.util.invariant(property !== undefined, 'dop.removeComputed needs a string or number as second parameter');
    
    var computed_pathid = dop.core.getPathId(dop.getObjectPath(object, false).concat(property)),
        shallWeRemoveAll = !isFunction(callback),
        isSameFunction,
        data_path = dop.data.path,
        removed = [],
        computed_ids,
        computed_id,
        computed,
        derivation_pathid,
        derivations,
        index,
        // total,
        index2,
        total2;

    if (isObject(data_path[computed_pathid]) && isArray(data_path[computed_pathid].computeds) && data_path[computed_pathid].computeds.length>0) {
        computed_ids = data_path[computed_pathid].computeds;
        for (index=0; index<computed_ids.length; ++index) {
            computed_id = computed_ids[index];
            computed = dop.data.computed[computed_id];
            isSameFunction = computed.function===callback;
            if (shallWeRemoveAll || isSameFunction) {
                // Deleting computing itself
                delete dop.data.computed[computed_id];
                // Removing id in computed
                computed_ids.splice(computed_ids.indexOf(computed_id), 1);
                // Removing derivations
                for (index2=0,total2=computed.derivations.length; index2<total2; ++index2) {
                    derivation_pathid = computed.derivations[index2];
                    derivations = data_path[derivation_pathid].derivations;
                    derivations.splice(derivations.indexOf(computed_id), 1);
                }
                index -= 1;
                removed.push(computed.function);
            }

            if (isSameFunction)
                break;
        }
    }

    return removed;
};




//////////  src/api/set.js

dop.set = function(object, property, value, options) {
    // dop.util.invariant(dop.isRegistered(object), 'Object passed to dop.set must be a registered object');
    (dop.isRegistered(object)) ?
        dop.core.set(object, property, value, options)
    :
        object[property] = value;
    return value;
};




//////////  src/api/setBroadcastFunction.js

dop.setBroadcastFunction = function (object, namefunction) {
    dop.util.invariant(dop.isRegistered(object), 'Object passed to dop.setBroadcastFunction must be a registered object');
    var path = dop.getObjectPath(object),
        object_id = path.shift();
    path.push(namefunction);
    dop.getObjectTarget(object)[namefunction] = function() {
        return dop.protocol.broadcast(object_id, path, arguments);
    }
    dop.getObjectTarget(object)[namefunction]._name = dop.cons.BROADCAST_FUNCTION;
};






//////////  src/core/api_transports/emitClose.js

dop.core.emitClose = function(node, socket) {
    if (node.listener)
        node.listener.emit('close', socket);
    node.emit('close', socket);
};




//////////  src/core/api_transports/emitConnect.js

dop.core.emitConnect = function(node) {
    node.connected = true;
    if (node.listener)
        node.listener.emit('connect', node);
    node.emit('connect');
    dop.core.sendMessages(node);
};




//////////  src/core/api_transports/emitDisconnect.js

dop.core.emitDisconnect = function(node) {
    node.connected = false;
    if (node.listener) {
        dop.core.unregisterNode(node);
        node.listener.emit('disconnect', node);
    }
    node.emit('disconnect');
};




//////////  src/core/api_transports/emitMessage.js

dop.core.emitMessage = function(node, message_string, message_raw) {

    // If server
    if (node.listener)
        node.listener.emit('message', node, message_string, message_raw);

    node.emit('message', message_string, message_raw);

    var messages;

    // Parsing messages
    if (typeof message_string == 'string' && message_string[0] == '[') { // https://jsperf.com/slice-substr-substring-test
        try { messages = dop.decode(message_string, node); } 
        catch(e) { /*console.log(e);*/ }
    }
    else 
        messages = message_string;


    // Managing protocol
    if (isArray(messages)) {

        // Detecting if is multimessage
        if (typeof messages[0] == 'number')
            messages = [messages];

        // Managing all messages one by one
        for (var i=0, t=messages.length, message, requests, request, request_id, response, instruction_type, message_typeof; i<t; i++) {

            message = messages[i];
            request_id = message[0];

            // If is a number we manage the request
            if (typeof request_id == 'number' && request_id !== 0) {

                // If is only one request
                message_typeof = dop.util.typeof(message[1]);
                requests = ((message_typeof=='number' && message_typeof!='array') || request_id<0) ? 
                    [request_id, message.slice(1)]
                :
                    requests = message;


                for (var j=1, t2=requests.length, instruction_function; j<t2; ++j) {
                    
                    request = requests[j];

                    if (dop.util.typeof(request)=='array' && ((typeof request[0]=='number' && request_id>0) || request_id<0)) {
                        
                        instruction_type = request[0];
                        instruction_function = 'on'+dop.protocol.instructions[instruction_type];

                        // REQUEST ===============================================================
                        if (request_id>0 && isFunction(dop.protocol[instruction_function]))
                            dop.protocol[instruction_function](node, request_id, request);


                        // RESPONSE ===============================================================
                        else {

                            request_id *= -1;

                            if (isObject(node.requests[request_id])) {

                                response = request;
                                request = node.requests[request_id];

                                instruction_type = request[1];
                                instruction_function = '_on'+dop.protocol.instructions[instruction_type];

                                if (isFunction(dop.protocol[instruction_function]))
                                    dop.protocol[instruction_function](node, request_id, request, response);
                                
                                dop.core.deleteRequest(node, request_id);
                            }

                        }

                    }
                }

            }

        }

    }






    // var messages, 
    //     user = (socket[dop.cons.TOKEN] === undefined) ?
    //         socket
    //     :
    //         node.users[ socket[dop.cons.TOKEN] ];






    // // Managing OSP protocol
    // if (dop.util.typeof(messages) == 'array')
    //     dop.core.manage.call(this, user, messages);

};




//////////  src/core/api_transports/emitOpen.js

dop.core.emitOpen = function(listener_node, socket, transport) {
    var node;
    // Client
    if (listener_node instanceof dop.core.node)
        node = listener_node;
    // Server
    else {
        node = new dop.core.node();
        node.listener = listener_node;
    }
    node.transport = transport;
    dop.core.registerNode(node);
    listener_node.emit('open', socket);
    return node;
};




//////////  src/core/api_transports/emitReconnect.js

dop.core.emitReconnect = function(node, oldSocket, newNode) {
    if (node.listener) {
        dop.core.unregisterNode(newNode);
        node.listener.emit('reconnect', node, oldSocket);
    }
    node.emit('reconnect', oldSocket);
    dop.core.sendMessages(node);
};





//////////  src/core/constructors/collector.js

dop.core.collector = function Collector(queue, index) {
    this.active = true;
    this.mutations = [];
    this.queue = queue;
    queue.splice(index, 0, this);
};

dop.core.collector.prototype.add = function(mutation) {
    if (this.active && (this.filter===undefined || this.filter(mutation)===true)) {
        this.mutations.push(mutation);
        return true;
    }
    return false;
};

dop.core.collector.prototype.emit = function() {
    this.destroy();
    return this.emitWithoutDestroy();
};

dop.core.collector.prototype.emitWithoutDestroy = function() {
    var snapshot = new dop.core.snapshot(this.mutations);
    snapshot.emit();
    this.mutations = [];
    return snapshot;
};

dop.core.collector.prototype.pause = function() {
    this.active = false;
};

dop.core.collector.prototype.resume = function() {
    this.active = true;
};

dop.core.collector.prototype.destroy = function() {
    this.active = false;
    this.queue.splice(this.queue.indexOf(this), 1);
};




//////////  src/core/constructors/listener.js

dop.core.listener = function Listener(args) {
    // Inherit emitter
    dop.util.merge(this, new dop.util.emitter);
    args.unshift(dop, this);
    this.options = args[2];
    this.transport = this.options.transport;
    this.listener = this.options.transport.apply(this, args);
};




//////////  src/core/constructors/node.js

dop.core.node = function Node() {
    // Inherit emitter
    dop.util.merge(this, new dop.util.emitter); //https://jsperf.com/inheritance-call-vs-object-assign
    this.connected = false;
    this.request_inc = 1;
    this.requests = {};
    this.message_queue = []; // Response / Request / instrunctions queue
    this.subscriber = {};
    this.owner = {};
    // Generating token
    do { this.token = dop.util.uuid() }
    while (typeof dop.data.node[this.token]=='object');
};



dop.core.node.prototype.send = function(message) {
    this.emit(dop.cons.SEND, message);
};

dop.core.node.prototype.disconnect = function() {
    this.emit(dop.cons.DISCONNECT);
};

dop.core.node.prototype.subscribe = function() {
    return dop.protocol.subscribe(this, arguments);
};

dop.core.node.prototype.unsubscribe = function(object) {
    dop.util.invariant(dop.isRegistered(object), 'Node.unsubscribe needs a subscribed object');
    return dop.protocol.unsubscribe(this, object);
};




//////////  src/core/constructors/observer.js

dop.core.observer = function Observer(callback, id) {
    this.callback = callback;
    this.id = id;
    this.observers = {}; // need it for destroy()
    this.observers_prop = {}; // need it for destroy()
};


dop.core.observer.prototype.observe = function(object, property) {
    dop.util.invariant(dop.isRegistered(object), 'observer.observe() needs a registered object as first parameter');
    var path = dop.getObjectPath(object);
    dop.util.invariant(isArray(path), 'observer.observe() The object you are passing is not allocated to a registered object');
    

    var path_id = dop.core.getPathId(path),
        data_path = dop.data.path,
        type = 'observers';

    // is observeProperty
    if (arguments.length === 2) {
        type = 'observers_prop';
        path_id += dop.core.pathSeparator(property);
    }

    if (data_path[path_id] === undefined)
        data_path[path_id] = {};

    if (data_path[path_id][type] === undefined)
        data_path[path_id][type] = {};

    data_path[path_id][type][this.id] = true;
    this[type][path_id] = true;

    return function unobserve() {
        delete data_path[path_id][type][this.id];
        delete this[type][path_id];
    }.bind(this);
};


// dop.core.observer.prototype.unobserve = function(object, property) {
//     dop.util.invariant(dop.isRegistered(object), 'observer.unobserve() needs a registered object as first parameter');
//     var path = dop.getObjectPath(object);
//     dop.util.invariant(isArray(path), 'observer.unobserve() The object you are passing is not allocated to a registered object');
    

//     var path_id = dop.core.getPathId(path);
//         data_path = dop.data.path,
//         type = 'observers';

//     // is observeProperty
//     if (arguments.length === 2) {
//         type = 'observers_prop';
//         path_id += dop.core.pathSeparator(property);
//     }

//     if (data_path[path_id] !== undefined && data_path[path_id][type] !== undefined) {
//         delete data_path[path_id][type][this.id];
//         delete this[type][path_id];
//     }
// };


dop.core.observer.prototype.destroy = function() {
    var path_id,
        data_path = dop.data.path;
        
    delete dop.data.observers[this.id];

    for (path_id in this.observers)
        delete data_path[path_id].observers[this.id];

    for (path_id in this.observers_prop)
        delete data_path[path_id].observers_prop[this.id];
};






//////////  src/core/constructors/snapshot.js

dop.core.snapshot = function Snapshot(mutations) {
    this.mutations = mutations;
    this.forward = true;
};


dop.core.snapshot.prototype.undo = function () {
    if (this.forward && this.mutations.length>0) {
        this.forward = false;
        this.setPatch(this.getUnpatch());
    }
};


dop.core.snapshot.prototype.redo = function () {
    if (!this.forward && this.mutations.length>0) {
        this.forward = true;
        this.setPatch(this.getPatch());
    }
};


dop.core.snapshot.prototype.emit = function () {
    // This is true if we have nodes subscribed to those object/mutations
    // Then we have to emit to nodes
    if (this.mutations.length>0 && dop.core.emitToObservers(this.mutations))
        dop.core.emitNodes(this.forward ? this.getPatch() : this.getUnpatch());
};


dop.core.snapshot.prototype.getPatch = function() {
    return this.patch = (this.patch === undefined) ?
        dop.core.getPatch(this.mutations)
    :
        this.patch;
};


dop.core.snapshot.prototype.getUnpatch = function() {
    return this.unpatch = (this.unpatch === undefined) ?
        dop.core.getUnpatch(this.mutations)
    :
        this.unpatch;     
};


dop.core.snapshot.prototype.setPatch = function(patch) {
    for (var object_id in patch)
        dop.core.setPatch(
            patch[object_id].object,
            patch[object_id].chunks,
            dop.core.setPatchMutator
        );
};




//////////  src/core/error.js

dop.core.error = {

    // warning: {
    //     TOKEN_REJECTED: 'User disconnected because is rejecting too many times the token assigned'
    // },

    reject_local: {
        OBJECT_NOT_FOUND: 'Object not found',
        NODE_NOT_FOUND: 'Node not found',
        TIMEOUT_REQUEST: 'Timeout waiting for response'
    },

    // Remote rejects
    reject_remote: {
        OBJECT_NOT_FOUND: 1,
        1: 'Remote object not found or not permissions to use it',
        SUBSCRIPTION_NOT_FOUND: 2,
        2: 'Subscription not found to unsubscribe this object',
        FUNCTION_NOT_FOUND: 3,
        3: 'Remote function not found to be called',
        CUSTOM_REJECTION: 4,
        // 4: ''
    }

};





//////////  src/core/mutators/delete.js

dop.core.delete = function(object, property) {
    var descriptor = Object.getOwnPropertyDescriptor(object, property);
    if (descriptor && descriptor.configurable) {
        
        var objectTarget = dop.getObjectTarget(object),
            objectProxy = dop.getObjectProxy(object),
            path,
            oldValue = objectTarget[property],
            deleted = delete objectTarget[property];

        if ((objectTarget===objectProxy || object===objectProxy) && (path = dop.getObjectPath(object)))
            dop.core.storeMutation({
                object: dop.getObjectProxy(objectTarget),
                prop: String(property),
                path: path,
                oldValue: dop.util.clone(oldValue)
            });

        // needed for dop.core.proxyObjectHandler.deleteProperty
        return deleted;
    }
};




//////////  src/core/mutators/pop.js

dop.core.pop = function(array) {
    if (array.length === 0)
        return undefined;
    var spliced = dop.core.splice(array, [array.length-1, 1]);
    return spliced[0];
};




//////////  src/core/mutators/push.js
// https://jsperf.com/push-against-splice OR https://jsperf.com/push-vs-splice
dop.core.push = function(array, items) {
    if (items.length === 0)
        return array.length;
    items.unshift(array.length, 0);
    dop.core.splice(array, items);
    return array.length;
};




//////////  src/core/mutators/reverse.js
// https://jsperf.com/array-reverse-algorithm
dop.core.reverse = function(array) {

    var objectTarget = dop.getObjectTarget(array),
        objectProxy = dop.getObjectProxy(array),
        path;

    if ((objectTarget===objectProxy || array===objectProxy) && (path = dop.getObjectPath(array))) {

        var total = objectTarget.length/2,
            index = 0,
            indexr,
            tempItem,
            swaps = [];

        for (;index<total; ++index) {
            indexr = objectTarget.length-index-1;
            if (index !== indexr) {
                tempItem = objectTarget[indexr];
                objectTarget[indexr] = objectTarget[index];
                objectTarget[index] = tempItem;
                swaps.push(index, indexr);
            }
        }


        if (swaps.length>0)
            dop.core.storeMutation({
                object: objectProxy,
                prop: dop.getObjectProperty(array),
                path: path,
                swaps: swaps
            });
    }
    else
        Array.prototype.reverse.call(objectTarget);

    return array;
};




//////////  src/core/mutators/set.js

dop.core.set = function(object, property, value, options) {

    if (!isObject(options))
        options = {}

    options.deep = typeof options.deep == 'boolean' ? options.deep : true
    options.shadow = typeof options.shadow == 'boolean' ? options.shadow : false

    // If is a different value
    if (object[property] !== value) {

        var descriptor = Object.getOwnPropertyDescriptor(object, property);

        if (!descriptor || (descriptor && descriptor.writable)) {
            var objectTarget = dop.getObjectTarget(object),
                objectProxy = dop.getObjectProxy(object),
                oldValue = objectTarget[property],
                length = objectTarget.length,
                isNewProperty = !objectTarget.hasOwnProperty(property),
                objectIsArray = isArray(objectTarget),
                path;
            
            // if (objectIsArray)
            //     property = Number(property);

            // object or array
            if (options.deep && dop.isPojoObject(value) && !(dop.isRegistered(value) && dop.getObjectParent(value) === objectProxy))
                objectTarget[property] = dop.core.configureObject(value, property, objectProxy);
            // computed value
            else if (isFunction(value) && value._name==dop.cons.COMPUTED_FUNCTION)
                objectTarget[property] = value(objectTarget, property, false, oldValue);
            // other
            else
                objectTarget[property] = value;

            if (
                !options.shadow &&
                (objectTarget===objectProxy || object===objectProxy) &&
                !(isFunction(oldValue) && isFunction(value)) &&
                (path = dop.getObjectPath(object))
            ) {
                var mutation = {
                    object: objectProxy,
                    prop: objectIsArray ? String(property) : property,
                    path: path,
                    value: dop.util.clone(value)
                };
                if (!isNewProperty)
                    mutation.oldValue = dop.util.clone(oldValue)

                dop.core.storeMutation(mutation);

                // If is array and length is different we must store the length 
                if (property !== 'length' && objectTarget.length !== length && objectIsArray)
                    dop.core.storeMutation({
                        object: objectProxy,
                        prop: 'length',
                        path: path,
                        value: objectTarget.length,
                        oldValue: length
                    });
            }
        }
    }
};




//////////  src/core/mutators/shift.js

dop.core.shift = function(array) {
    if (array.length === 0)
        return undefined;
    var spliced = dop.core.splice(array, [0, 1]);
    return spliced[0];
};




//////////  src/core/mutators/sort.js
// http://stackoverflow.com/a/234777/1469219 http://stackoverflow.com/a/38905402/1469219
// https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
// http://khan4019.github.io/front-end-Interview-Questions/sort.html#bubbleSort
// https://github.com/benoitvallon/computer-science-in-javascript/tree/master/sorting-algorithms-in-javascript
dop.core.sort = function(array, compareFunction) {
    var objectTarget = dop.getObjectTarget(array),
        objectProxy = dop.getObjectProxy(array),
        copy = objectTarget.slice(0),
        output, swaps, path;

    output = Array.prototype.sort.call(objectTarget, compareFunction);

    if ((objectTarget===objectProxy || array===objectProxy) && (path = dop.getObjectPath(array))) {
        swaps = dop.core.sortDiff(objectTarget, copy);
        if (swaps.length>1)
            dop.core.storeMutation({
                object: dop.getObjectProxy(array),
                prop: dop.getObjectProperty(array),
                path: path,
                swaps: swaps
            });
    }

    return output;
};


dop.core.sortDiff = function (array, copy) {

    var total = copy.length,
        swaps = [],
        index1 = 0,
        index2, tmp;

    for (;index1<total; ++index1) {
        if (array[index1] !== copy[index1]) {
            index2 = copy.indexOf(array[index1]);
            tmp = copy[index1];
            copy[index1] = copy[index2];
            copy[index2] = tmp;
            swaps.push(index1, index2);
        }
    }

    return swaps;
};




// function diffArray(array) {
//     var copy = array.slice(0),
//         swaps = [],
//         index = 0,
//         total = copy.length,
//         indexNew, tmp;

//     array.sort();

//     for (;index<total; ++index) {
//         if (copy[index] !== array[index]) {
//             indexNew = copy.indexOf(array[index]);
//             tmp = copy[index];
//             copy[index] = copy[indexNew];
//             copy[indexNew] = tmp;
//             swaps.push([index, indexNew]);
            
//             console.log([index, indexNew], copy );
//             if (indexNew < index) {
//                 console.log( 'lol' );
//             }
            
//             // swapeds[indexNew] = true;
//             // if (indexCache!==indexNew && indexCache !== index) {
//             //     swapeds[indexCache] = true;
//             //     swap(copy, indexNew, indexCache);
//             //     swaps.push([indexNew, indexCache]);
//             //     console.log([indexNew, indexCache], copy, swapeds );
//             // }
//         }
//     }

//     return swaps;
// }




//////////  src/core/mutators/splice.js

dop.core.splice = function(array, args) {

    var objectTarget = dop.getObjectTarget(array),
        objectProxy = dop.getObjectProxy(array),
        originalLength = objectTarget.length,
        spliced,
        path;

    // Splicing!!
    spliced = Array.prototype.splice.apply(objectTarget, args);

    // If enviroment do not allow proxies (objectTarget and objectProxy are same object in that case) 
    // or if the array is the proxy itself
    path = dop.getObjectPath(array)
    if (path) {

        var argslength = args.length,
            length = objectTarget.length,
            index=2,
            start = Number(args[0]),
            // deleteCount = (Number(args[1])>0) ? args[1] : 0,
            itemslength = (args.length>2) ? (args.length-2) : 0,
            item;


        // Defaults for start
        if (isNaN(start))
            start = 0;
        else if (start<0)
            start = (length+start < 0) ? 0 : length+start;
        else if (start>originalLength)
            start = originalLength;


        // // We dont need update becase no items remaining after splice
        // end = (argslength===1) ? 0 :
        //     // If deleteCount is the same of items to add means the new lengh is the same and we only need to update the new elements
        //     (argslength>2 && deleteCount===itemslength) ?
        //         start+deleteCount
        //     :
        //         objectTarget.length;


        // We must register new objects
        for (;index<argslength; ++index, ++start) {
            item = args[index];
            if (dop.isPojoObject(item))
                objectTarget[start] = dop.core.configureObject(
                    item,
                    start,
                    objectProxy
                );
        }

        // Storing mutation
        if ((objectTarget===objectProxy || array===objectProxy) && (originalLength!==length || itemslength>0)) {
            if (args[0]<0)
                args[0] = array.length+args[0];
            var mutation = {
                object: objectProxy,
                prop: dop.getObjectProperty(array),
                path: path,
                splice: args
            };

            if (spliced.length > 0)
                mutation.spliced = dop.util.clone(spliced);

            if (length !== originalLength)
                mutation.oldLength = originalLength;

            dop.core.storeMutation(mutation);
        }

    }

    return spliced;
};




//////////  src/core/mutators/swap.js

dop.core.swap = function(array, swaps) {
    var objectTarget = dop.getObjectTarget(array),
        objectProxy = dop.getObjectProxy(array);

    var result = dop.util.swap(objectTarget, swaps);

    if (objectTarget===objectProxy || array===objectProxy)
        dop.core.storeMutation({
            object: objectProxy,
            prop: dop.getObjectProperty(array),
            path: dop.getObjectPath(array),
            swaps: swaps.slice(0)
        });

    return result;
};




//////////  src/core/mutators/unshift.js

dop.core.unshift = function(array, items) {
    if (items.length === 0)
        return array.length;
    items.unshift(0, 0);
    dop.core.splice(array, items);
    return array.length;
};





//////////  src/core/objects/configureObject.js

var canWeProxy = typeof Proxy == 'function';
dop.core.configureObject = function(object, propertyParent, parent) {

    // Creating a copy if is another object registered
    if (dop.isRegistered(object))
        return dop.core.configureObject(
            dop.util.clone(object),
            propertyParent,
            parent
        );

    // // Removing fake dop property
    // delete object[dop.cons.DOP];


    // Setting ~DOP object
    var object_dop = {}, object_proxy, object_target;
    object_dop._ = parent; // parent
    object_dop.pr = isArray(parent) ? Number(propertyParent) : propertyParent; // property
    
    // Making proxy object
    if (canWeProxy) {
        object_proxy = object_dop.p = new Proxy(object, dop.core.proxyObjectHandler);
        object_target = object_dop.t = object;
    }
    else
        object_proxy = object_target = object_dop.p = object_dop.t = object;

    // root
    object_dop.r = (parent === undefined) ? object_proxy : dop.getObjectDop(parent).r;
    


    // // Object parent level and more
    // if (parent === undefined) {
    //     object_dop.r = object_proxy;  // root
    //     object_dop.l = 1; // deep level [1,"prop","arr"] this is level 3
    //     object_dop.ia = false; // is inside of array
    // }
    // else {
    //     var object_dop_parent = dop.getObjectDop(parent);
    //     object_dop.l = object_dop_parent.l+1;  // deep level [1,"prop","arr"] this is level 3
    //     object_dop.ia = (object_dop_parent.ia || isArray(parent)); // is inside of array
    // }


    Object.defineProperty(object_target, dop.cons.DOP, {
        value:object_dop,
        enumerable:false,
        configurable:false,
        writable:false
    });


    // Deep objects (Recursion)
    var property, 
        value,
        path,
        is_array = isArray(object_target),
        is_function;

    for (property in object_target) {
        if (is_array)
            property = Number(property);
        value = object_target[property];
        is_function = isFunction(value);
        // remote function
        if (is_function && value._name==dop.cons.REMOTE_FUNCTION_UNSETUP) {
            path = dop.getObjectPath(object);
            object_target[property] = value(path[0], path.slice(1).concat(property));
        }
        // storing computed value function
        else if (is_function && value._name==dop.cons.COMPUTED_FUNCTION)
            object_target[property] = value(object_proxy, property, false, undefined);
        // object or array
        else if (dop.isPojoObject(value))
            object_target[property] = dop.core.configureObject(value, property, object_proxy);
    }


    // if (isObject(parent))
        // object_dop._ = (dop.isRegistered(parent)) ? dop.getObjectTarget(parent) : parent;

    // Adding traps for mutations methods of arrays
    if (dop.util.typeof(object_target) == 'array')
        Object.defineProperties(object_target, dop.core.proxyArrayHandler);


    return object_proxy;
};




//////////  src/core/objects/createCollector.js

dop.core.createCollector = function(queue, index) {
    var collector = new dop.core.collector(queue, index);
    return collector;
};




//////////  src/core/objects/createComputed.js

dop.core.createComputed = function (object, prop, f, shallWeSet, oldValue) {
    var data_path = dop.data.path,
        value,
        computed_id = dop.data.computed_inc++,
        computed = {
            object_root: dop.getObjectRoot(object),
            prop: prop,
            function: f,
            derivations: []
        },
        path = dop.getObjectPath(object, false);

    computed.path = path.slice(1);
    computed.pathid = dop.core.getPathId(path.concat(prop));

    if (data_path[computed.pathid] === undefined)
        data_path[computed.pathid] = {};
    
    if (data_path[computed.pathid].computeds === undefined)
        data_path[computed.pathid].computeds = [];

    dop.data.computed[computed_id] = computed;
    value = dop.core.updateComputed(computed_id, computed, object, oldValue);

    // Setting value
    if (shallWeSet)
        dop.core.set(object, prop, value);

    return value;
};




//////////  src/core/objects/emitToObservers.js

dop.core.emitToObservers = function(mutations) {

    var mutation,
        path_id,
        observer_id,
        mutationsToEmitByIdObserver = {},
        mutationsWithSubscribers = false,
        data_path = dop.data.path,
        index = 0,
        total = mutations.length;

    for (;index<total; ++index) {
        mutation = mutations[index];
        path_id = mutation.path_id;

        if (!mutationsWithSubscribers && isObject(dop.data.object[dop.getObjectId(mutation.object)]))
            mutationsWithSubscribers = true;

        // .observers
        if (data_path[path_id] !== undefined && data_path[path_id].observers !== undefined) {
            for (observer_id in data_path[path_id].observers) {
                if (mutationsToEmitByIdObserver[observer_id] === undefined)
                    mutationsToEmitByIdObserver[observer_id] = [];
                mutationsToEmitByIdObserver[observer_id].push(mutation);
            }
        }

        // .observers_prop
        if (mutation.swaps === undefined) { // If mutation is swaps type we should skip because does not have observers_prop and also the length never changes
            path_id += dop.core.pathSeparator(mutation.splice===undefined ? mutation.prop : 'length');
            if (data_path[path_id] !== undefined && data_path[path_id].observers_prop !== undefined) {
                for (observer_id in data_path[path_id].observers_prop) {
                    if (mutationsToEmitByIdObserver[observer_id] === undefined)
                        mutationsToEmitByIdObserver[observer_id] = [];
                    // We have to check this because we dont want to duplicate
                    if (mutationsToEmitByIdObserver[observer_id].indexOf(mutation) == -1)
                        mutationsToEmitByIdObserver[observer_id].push(mutation);
                }
            }
        }

    }

    // Emiting
    for (observer_id in mutationsToEmitByIdObserver) {
        var observer = dop.data.observers[observer_id];
        if (observer !== undefined) // We need to make sure that the observer still exists, because maybe has been removed after calling previous observers
            observer.callback(mutationsToEmitByIdObserver[observer_id]);
    }

    return mutationsWithSubscribers;
};




//////////  src/core/objects/getMutationInverted.js

dop.core.getMutationInverted = function(mutation) {

    var mutationInverted = {
        object: mutation.object,
        path: mutation.path,
        prop: mutation.prop
    };

    // splice
    if (mutation.splice !== undefined) {
        var splice = mutation.splice,
            spliced = (mutation.spliced === undefined) ? [] : mutation.spliced;

        mutationInverted.splice = [splice[0], splice.length-2];
        Array.prototype.push.apply(mutationInverted.splice, spliced);

        mutationInverted.spliced = splice.slice(2);
        if (mutationInverted.spliced.length === 0)
            delete mutationInverted.spliced;
    }

    // swaps
    else if (mutation.swaps !== undefined)
        mutationInverted.swaps = mutation.swaps.slice(0).reverse();

    // new value
    else if (!mutation.hasOwnProperty('oldValue'))
        mutationInverted.oldValue = mutation.value;

    // delete
    else if (!mutation.hasOwnProperty('value'))
        mutationInverted.value = mutation.oldValue;

    // set
    else {
        mutationInverted.oldValue = mutation.value;
        mutationInverted.value = mutation.oldValue;
    }

    return mutationInverted;
};




//////////  src/core/objects/getPatch.js

dop.core.getPatch = function(mutations, isUnpatch) {

    var patchs = {},
        index = 0,
        total = mutations.length,
        mutation,
        object_id;

    for (;index<total; ++index) {
        mutation = isUnpatch ? dop.core.getMutationInverted(mutations[index]) : mutations[index];
        object_id = dop.getObjectId(mutation.object);
        if (patchs[object_id] === undefined)
            patchs[object_id] = {chunks:[{}], object:dop.getObjectRoot(mutation.object)};
        dop.core.injectMutationInPatch(patchs[object_id], mutation);
        // console.log(JSON.stringify(patchs[object_id].chunks))
    }

    return patchs;
};



// dop.core.objectIsStillStoredOnPath = function(object) {

//     var path = dop.getObjectDop(object),
//         index = path.length-1,
//         parent;

//     for (;index>0; --index) {
//         // parent = (index>1) ? dop.getObjectDop(object)._ : dop.data.object[path[0]];
//         if (index>1) {
//             parent = dop.getObjectParent(object);
//             if (parent[path[index]] !== object)
//                 return false;
//             object = dop.getObjectProxy(parent);
//         }
//         // else
//             // return false;
//     }

//     return true;
// };




//////////  src/core/objects/getPathId.js

dop.core.getPathId = function(path) {

    var index = 0,
        total = path.length,
        path_id = '';

    for (; index<total; ++index)
        path_id += dop.core.pathSeparator(path[index]);

    return path_id;
};




//////////  src/core/objects/getUnpatch.js

dop.core.getUnpatch = function(mutations) {
    return dop.core.getPatch(mutations.slice(0).reverse(), true);
};




//////////  src/core/objects/injectMutationInPatch.js

dop.core.injectMutationInPatch = function(patch, mutation) {

    var prop = mutation.prop,
        path = mutation.path,
        value = mutation.value,
        isMutationSplice = mutation.splice!==undefined,
        isMutationSwaps = mutation.swaps!==undefined,
        isMutationArray = isMutationSplice || isMutationSwaps,
        typeofValue = dop.util.typeof(value),
        index = 1,
        chunk = patch.chunks[patch.chunks.length-1],
        chunkParent = chunk,
        chunkNext = {},
        chunkNextParent = chunkNext,
        chunkNextRoot = chunkNext,
        tofCurrentObject,
        specialInstruction,
        instructionsPatchs = dop.protocol.instructionsPatchs,
        isNewObject = false,
        isNewChunk = false,
        propPath,
        valueMerged,
        newSpecialInstruction;



    // Going deep
    for (;index<path.length; ++index) {

        propPath = path[index];
        chunkParent = chunk;
        chunkNextParent = chunkNext;
        chunkNext = chunkNext[propPath] = {};
        tofCurrentObject = dop.util.typeof(chunk[propPath]);


        if (tofCurrentObject == 'array') {
            specialInstruction = chunk[propPath];
            // Is a new object
            if (specialInstruction[0] === instructionsPatchs.object) {
                isNewObject = true;
                chunk = specialInstruction[1];
            }
            else if (!isMutationArray || (isMutationArray && index+1<path.length)) {
                isNewChunk = true;
                chunk = chunkNext;
                patch.chunks.push(chunkNextRoot);
            }
        }

        else if (!isNewChunk && isMutationArray && tofCurrentObject == 'object') {
            // isNewChunk = true;
            chunkParent = chunkNextParent;
            chunk = chunkNext; 
            patch.chunks.push(chunkNextRoot);
        }

        else if (tofCurrentObject == 'object')
            chunk = chunk[propPath];

        else
            chunk = chunk[propPath] = {};
    }


    /// INJECTING ///

    // Objects or array
    if (typeofValue == 'object' || typeofValue == 'array') {
        valueMerged = dop.util.merge(typeofValue == 'array' ? [] : {}, value);
        if (isNewObject)
            chunk[prop] = valueMerged;
        else {
            chunk[prop] = [
                instructionsPatchs.object,
                valueMerged
            ];
        }
    }


    // Mutations over arrays
    else if (isMutationArray) {
        if (isNewObject)
            (isMutationSplice) ?
                Array.prototype.splice.apply(chunk, mutation.splice.slice(0))
            :
                dop.util.swap(chunk, mutation.swaps.slice(0));

        else {
            newSpecialInstruction = (isMutationSplice) ?
                [instructionsPatchs.splice, mutation.splice.slice(0)]
            :
                [instructionsPatchs.swaps, mutation.swaps.slice(0)]

            if (!isArray(chunkParent[prop]))
                chunkParent[prop] = newSpecialInstruction;

            else {
                if (isNumber(chunkParent[prop][0]))
                    chunkParent[prop] = [chunkParent[prop]]

                chunkParent[prop].push(newSpecialInstruction)
            }
        }
    }


    // Others values
    else
        chunk[prop] = value;
};


// isCurrentNewObject
// isCurrentArrayMutation
// isValueNewObject
// isValueArrayMutation
// isTheLastOne
// isNewObject




//////////  src/core/objects/pathSeparator.js

dop.core.pathSeparator = function(property) {
    return property+'.'+property;
};




//////////  src/core/objects/proxyArrayHandler.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Mutator_methods
dop.core.proxyArrayHandler = {
    splice: {value:function() {
        return dop.core.splice(this, Array.prototype.slice.call(arguments,0));
    }},
    shift: {value: function() {
        return dop.core.shift(this, Array.prototype.slice.call(arguments,0));
    }},
    pop: {value:function() {
        return dop.core.pop(this, Array.prototype.slice.call(arguments,0));
    }},
    push: {value:function() {
        return dop.core.push(this, Array.prototype.slice.call(arguments,0));
    }},
    unshift: {value:function() {
        return dop.core.unshift(this, Array.prototype.slice.call(arguments,0));
    }},
    reverse: {value:function() {
        return dop.core.reverse(this);
    }},
    sort: {value:function(compareFunction) {
        return dop.core.sort(this, compareFunction);
    }},
    /*fill: {value:function() {
        return dop.core.fill.apply(this, arguments);
    }},
    copyWithin: {value:function() {
        return dop.core.copyWithin.apply(this, arguments);
    }},*/
};




//////////  src/core/objects/proxyObjectHandler.js

dop.core.proxyObjectHandler = {
    set: function(object, property, value) {
        dop.core.set(dop.getObjectProxy(object), property, value);
        return true;
    },
    deleteProperty: function(object, property) {
        dop.core.delete(dop.getObjectProxy(object), property) !== undefined;
        return true;
    },
    get: function(object, property) {
        if (dop.data.gets_collecting && typeof property == 'string' && property !== dop.cons.DOP && object[property] !== Array.prototype[property])
            dop.data.gets_paths.push(dop.getObjectPath(object, false).concat(property));

        return object[property];
    }
};
            /*var gets_paths = dop.data.gets_paths,
                last_path = gets_paths[gets_paths.length-1],
                path = dop.getObjectPath(object).concat(property);

            if (gets_paths.length>0 && path.length>last_path.length)
                gets_paths.pop();
            
            gets_paths.push(path);*/





//////////  src/core/objects/runDerivations.js

dop.core.runDerivations = function(path_id) {
    if (dop.data.path[path_id] !== undefined && dop.data.path[path_id].derivations !== undefined) {
        var derivations = dop.data.path[path_id].derivations,
            computed,
            computed_id,
            object,
            total = derivations.length,
            index = 0;

        for (;index<total; ++index) {
            computed_id = derivations[index];
            computed = dop.data.computed[computed_id];
            object = dop.util.get(computed.object_root, computed.path);
            if (object !== undefined)
                dop.core.set(
                    object,
                    computed.prop,
                    // computed.function.call(object, object[computed.prop])
                    dop.core.updateComputed(computed_id, computed, object, object[computed.prop])
                );
        }
    }
};




//////////  src/core/objects/setPatch.js

dop.core.setPatch = function(object, patch, mutator) {
    if (!isArray(patch))
        patch = [patch];
    
    for (var index=0,total=patch.length; index<total; ++index)
        dop.util.path(patch[index], null, object, mutator);

    return object;
};


dop.core.setPatchFunctionMutator = function(destiny, prop, value, typeofValue, path){
    if (isFunction(value) && value._name==dop.cons.REMOTE_FUNCTION_UNSETUP)
        dop.set(destiny, prop, value(dop.getObjectId(destiny), path.slice(0)));
    else
        return dop.core.setPatchMutator(destiny, prop, value, typeofValue, path);
};


dop.core.setPatchMutator = function(destiny, prop, value, typeofValue) {
    var typeInstruction,
        instructionsPatchs = dop.protocol.instructionsPatchs,
        mutation;

    // console.log( prop, typeofValue, value );
    if (typeofValue == 'array') {
        typeInstruction = value[0];

        // New object/array
        if (typeInstruction === instructionsPatchs.object)
            dop.set(destiny, prop, dop.util.clone(value[1]));

        // Array mutations
        else if (isArray(destiny[prop])) {
            if (!isArray(typeInstruction))
                value = [value];

            for (var index=0,total=value.length; index<total; ++index) {
                mutation = value[index];

                // Splice
                if (mutation[0] === instructionsPatchs.splice)
                    dop.core.splice(destiny[prop], mutation[1]);

                else if (mutation[0] === instructionsPatchs.swaps)
                    dop.core.swap(destiny[prop], mutation[1]);
            }
        }

        return true; // Skiping to dont go inside of [instructionPatch, ...]
    }

    // Delete
    else if (typeofValue=='undefined')
        dop.del(destiny, prop);

    // Set value
    else if (typeofValue!='object')
        dop.set(destiny, prop, value);
};


    

    // // Array mutations
    // if (typeofValue=='object' && typeofDestiny=='array' && value.hasOwnProperty(dop.cons.DOP)) {

    //     var mutations = value[dop.cons.DOP],
    //         mutation,
    //         index=0,
    //         total=mutations.length,
    //         typeArrayMutation;

    //     // if (typeofDestiny!='array')
    //     //     dop.set(destiny, prop, []);

    //     for (;index<total; ++index) {
    //         typeArrayMutation = mutations[index][0]; // 0=swaps 1=splices
    //         mutation = mutations[index].slice(1);

    //         // swap
    //         if (typeArrayMutation===0)
    //             dop.core.swap(destiny[prop], mutation);

    //         // length
    //         else if (typeArrayMutation===2)
    //             dop.set(destiny[prop], 'length', mutation[0]);

    //         // splice & set & del
    //         else {
    //             // We have to update the length of the array in case that is lower than before
    //             if (destiny[prop].length<mutation[0])
    //                 dop.getObjectTarget(destiny[prop]).length = mutation[0];
                    
    //             // set
    //             if (mutation.length===3 && mutation[1]===1) {
    //                 (mutation[2] === undefined) ?
    //                     dop.del(destiny[prop], mutation[0])
    //                 :
    //                     dop.set(destiny[prop], mutation[0], mutation[2]);
    //             }

    //             // splice
    //             else
    //                 dop.core.splice(destiny[prop], mutation);
    //         }
    //     }

    //     // if (typeof value.length == 'number' && value.length>-1)
    //         // destiny[prop].length = value.length;

    //     return true; // Skiping to dont go inside of {~dop:...}
    // }

    // else //if (path.length > 1) {

    //     // Objects
    //     if (typeofValue=='object' && typeofDestiny!='object') //!destiny.hasOwnProperty(prop)
    //         dop.set(destiny, prop, {});

    //     // Arrays
    //     else if (typeofValue=='array' && typeofDestiny!='array')
    //         dop.set(destiny, prop, []);

    //     // Delete
    //     else if (typeofValue=='undefined')
    //         dop.del(destiny, prop);

    //     // Set value
    //     else if (typeofValue!='object')
    //         dop.set(destiny, prop, value);
    // //}





//////////  src/core/objects/storeMutation.js

dop.core.storeMutation = function(mutation) {

    var collectors = dop.data.collectors,
        paths = dop.data.path,
        index=0,
        total=collectors.length,
        path_id_parent,
        path_id;

    // Saving path_id
    path_id_parent = path_id = mutation.path_id = dop.core.getPathId(mutation.path);

    if (mutation.splice===undefined && mutation.swaps===undefined)
        path_id += dop.core.pathSeparator(mutation.prop);


    // Interceptors objects
    if (!dop.core.runInterceptors(paths[path_id_parent], 'interceptors', mutation))
        return


    // Interceptors properties
    if (!dop.core.runInterceptors(paths[path_id], 'interceptors_prop', mutation))
        return


    // Collectors
    for (;index<total; index++) {
        if (collectors[index].add(mutation)) {
            dop.core.runDerivations(path_id_parent);
            dop.core.runDerivations(path_id);
            return
        }
    }


    var snapshot = new dop.core.snapshot([mutation]);
    snapshot.emit();

    dop.core.runDerivations(path_id_parent);
    dop.core.runDerivations(path_id);
};


dop.core.runInterceptors = function(interceptors, type, mutation) {
    if (interceptors && (interceptors=interceptors[type]) && interceptors.length>0)
        for (var index=0,total=interceptors.length; index<total; ++index)
            if (interceptors[index](mutation, dop.getObjectTarget(mutation.object)) !== true)
                return false;

    return true;
};


// dop.core.runInterceptors = function(interceptors, type, mutation) {
//     if (interceptors && (interceptors=interceptors[type]) && interceptors.length>0) {
//         for (var index=0,total=interceptors.length, tosplice=[]; index<total; ++index) {
//             if (interceptors[index] === undefined)
//                 tosplice.push(index);
//             else if (interceptors[index](mutation) !== true)
//                 return false;
//         }
//         for (index=0,total=tosplice.length; index<total; ++index)
//             tosplice.splice(tosplice[index], 1);
//     }

//     return true;
// };





//////////  src/core/objects/updateComputed.js

dop.core.updateComputed = function (computed_id, computed, context, oldValue) {

    var data_path = dop.data.path,
        derived_paths,
        derived_pathsids = computed.derivations,
        derived_path,
        derived_pathid,
        value,
        index = 0,
        total,
        index2,
        total2;


    // Running function and saving paths from getters
    dop.data.gets_collecting = true;
    value = computed.function.call(context, oldValue);
    dop.data.gets_collecting = false;
    derived_paths = dop.data.gets_paths;
    dop.data.gets_paths = [];


    // Generating and storing paths ids
    for (total=derived_paths.length; index<total; ++index) {
        derived_path = derived_paths[index];
        derived_pathid = '';
        for (index2=0,total2=derived_path.length; index2<total2; ++index2) {
            derived_pathid += dop.core.pathSeparator(derived_path[index2]);
            if (index2>0) {
                if (data_path[derived_pathid] === undefined)
                    data_path[derived_pathid] = {};
                
                if (data_path[derived_pathid].derivations === undefined)
                    data_path[derived_pathid].derivations = [];
                
                if (data_path[derived_pathid].derivations.indexOf(computed_id) < 0) {
                    data_path[derived_pathid].derivations.push(computed_id);
                    derived_pathsids.push(derived_pathid);
                }
            }
        }
    }


    // Storing computed in dop.data 
    if (data_path[computed.pathid].computeds.indexOf(computed_id) === -1)
        data_path[computed.pathid].computeds.push(computed_id);


    return value;
};





//////////  src/core/protocol/connector.js

dop.core.connector = function(args) {
    var node = new dop.core.node();
    args.unshift(dop, node);
    node.options = args[2];
    node.transport = node.options.transport;
    node.options.transport.apply(this, args);
    return node;
};





//////////  src/core/protocol/createAsync.js

dop.core.createAsync = function() {
    var resolve, reject,
    promise = new Promise(function(res, rej) {
        resolve = res;
        reject = rej;
    });
    promise.resolve = resolve;
    promise.reject = reject;
    return promise;
};



// mypromise = dop.core.createAsync();
// mypromise.then(function(v) {
//     console.log('yeah',v)
// });
// setTimeout(function() {
//     mypromise.resolve(1234567890)
// },1000);


// dop.core.createAsync = function() {
//     var observable = Rx.Observable.create(function(observer) {
//         observable.resolve = function(value) {
//             observer.onNext(value);
//             observer.onCompleted();
//         };
//         observable.reject = observer.onError;
//     });
//     return observable;
//     // return {stream:observable,resolve:observer.onNext,reject:observer.onError,cancel:cancel};
// };
// mypromise = dop.core.createAsync();
// mypromise.subscribe(function(v) {
//     console.log('yeah',v);
// });
// setTimeout(function() {
//     mypromise.resolve(1234567890);
// },1000);




// https://github.com/ReactiveX/rxjs/issues/556
// function getData(num) {
//   return new Promise((resolve, reject) => {
//     resolve(num + 1);
//   });
// }

// async function create() {
//   var list = await Rx.Observable.range(1, 5)
//     .flatMap(num => getData(num))
//     .toArray().toPromise();

//   return list;
// }

// console.clear();

// Rx.Observable.fromPromise(create()).subscribe(list => {
//   console.log(list);
// }, err => {
//   console.log(err);
// });





//////////  src/core/protocol/createRemoteFunction.js

dop.core.createRemoteFunction = function(node) {
    var f = function (object_id, path) {
        // // http://jsperf.com/dynamic-name-of-functions
        // return new Function(
        //     "var a=arguments;return function " + path[path.length-1] + "(){return a[0](a[1], a[2], a[3], arguments)}"
        // )(dop.protocol.call, node, object_id, path)
        var f2 = function $DOP_REMOTE_FUNCTION() {
            return dop.protocol.call(node, object_id, path, arguments);
        }
        f2._name = dop.cons.REMOTE_FUNCTION
        return f2;
    }
    f._name = dop.cons.REMOTE_FUNCTION_UNSETUP;
    return f;
};





//////////  src/core/protocol/createRequest.js

dop.core.createRequest = function(node) {
    var request_id = node.request_inc++,
        request = Array.prototype.slice.call(arguments, 1);

    node.requests[request_id] = request;
    request.unshift(request_id);
    request.promise = dop.core.createAsync();

    return request;
};




//////////  src/core/protocol/createResponse.js

dop.core.createResponse = function() {
    arguments[0] = arguments[0]*-1;
    return Array.prototype.slice.call(arguments, 0);
};




//////////  src/core/protocol/decode.js
var regexpdate = /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\dZ$/,
    regexpsplit = /\/(.+)\/([gimuy]{0,5})/;

dop.core.decode = function(property, value, node, undefineds) {

    if (typeof value == 'string') {

        if (value == dop.protocol.instructionsPatchs.function)
            return dop.core.createRemoteFunction(node);

        if (value == dop.protocol.instructionsPatchs.undefined && isObject(undefineds)) {
            undefineds.push([this, property]); // http://stackoverflow.com/questions/17648150/how-does-json-parse-manage-undefined
            return undefined;
        }

        if (value == dop.protocol.instructionsPatchs.infinity)
            return Infinity;

        if (value == dop.protocol.instructionsPatchs._infinity)
            return -Infinity;

        if (value == dop.protocol.instructionsPatchs.nan)
            return NaN;

        if (regexpdate.exec(value))
            return new Date(value);

        if (value.substr(0,2) == dop.protocol.instructionsPatchs.regex) {
            var split = regexpsplit.exec(value.substr(2)); // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp
            return new RegExp(split[1], split[2]);
        }

        if (value[0] == '~') // https://jsperf.com/charat-vs-index/5
            return value.substring(1);


    }

    return value;

};






//////////  src/core/protocol/deleteRequest.js

dop.core.deleteRequest = function(node, request_id) {
    clearTimeout(node.requests[request_id].timeout);
    delete node.requests[request_id];
};





//////////  src/core/protocol/emitNodes.js

dop.core.emitNodes = function(patch) {
    var object_id, node_token, node, object_data, chunks;
    for (object_id in patch) {
        if (isObject(dop.data.object[object_id])) {
            object_data = dop.data.object[object_id];
            for (node_token in object_data.node) {
                if (object_data.node[node_token].subscriber===1) {
                    node = dop.data.node[node_token];
                    chunks = patch[object_id].chunks;
                    dop.protocol.patch(node, Number(object_id), chunks.length>1 ? chunks : chunks[0]);
                }
            }
        }
    }
};




//////////  src/core/protocol/encode.js

dop.core.encode = function(property, value) {

    var tof = typeof value;

    if (tof == 'undefined') // http://stackoverflow.com/questions/17648150/how-does-json-parse-manage-undefined
        return dop.protocol.instructionsPatchs.undefined;

    if (tof == 'string' && value[0] == '~')
        return '~'+value;
    
    if (tof == 'number' && isNaN(value))
        return dop.protocol.instructionsPatchs.nan;

    if (tof == 'object' && value instanceof RegExp)
        return dop.protocol.instructionsPatchs.regex + value.toString();

    if (value === Infinity)
        return dop.protocol.instructionsPatchs.infinity;

    if (value === -Infinity)
        return dop.protocol.instructionsPatchs._infinity;

    return value;
};


// // Extending example
// var encode = dop.core.encodeUtil;
// dop.core.encodeUtil = function(property, value) {
//     if (typeof value == 'boolean')
//         return '~BOOL';
//     return encode(property, value);
// };






//////////  src/core/protocol/encodeFunction.js

dop.core.encodeFunction = function(property, value) {
    return (isFunction(value) && !dop.isBroadcastFunction(value)) ? 
        dop.protocol.instructionsPatchs.function
    : 
        dop.core.encode(property, value);
};




//////////  src/core/protocol/getRejectError.js

dop.core.getRejectError = function(error) {
    if (typeof error == 'number' && dop.core.error.reject_remote[error] !== undefined) {
        var args = Array.prototype.slice.call(arguments, 1);
        args.unshift(dop.core.error.reject_remote[error]);
        return dop.util.sprintf.apply(this, args);
    }
    return error;  
};




//////////  src/core/protocol/localProcedureCall.js

dop.core.localProcedureCall = function(f, args, resolve, reject, configureReq, scope) {
    var req = dop.core.createAsync(), output;
    if (isFunction(configureReq))
        req = configureReq(req);

    args.push(req);
    req.then(resolve).catch(reject);
    output = f.apply(scope||req, args);

    // Is sync
    if (output !== req)
        req.resolve(output);
};




//////////  src/core/protocol/multiEncode.js

// dop.core.multiEncode = function() {
//     var encoders = arguments,
//         length = encoders.length, v;
//     return function recursion(property, value, index) {
//         if (index>=length)
//             return value;
//         else if (index === undefined) {
//             v = value;
//             index = 0;
//         }
//         v = encoders[index](property, value);
//         return (v!==value) ? v : recursion(property, value, index+1);
//     }
// };




//////////  src/core/protocol/registerNode.js

dop.core.registerNode = function(node) {
    dop.data.node[node.token] = node;
};




//////////  src/core/protocol/registerObjectToNode.js

dop.core.registerObjectToNode = function(node, object) {

    var object_id = dop.getObjectId(object), object_data;

    if (dop.data.object[object_id] === undefined)
        dop.data.object[object_id] = {
            object: object,
            nodes_total: 0,
            node: {}
        };
    
    object_data = dop.data.object[object_id];

    if (object_data.node[node.token] === undefined) {
        object_data.nodes_total += 1;
        object_data.node[node.token] = {
            subscriber: 0, // 0 or 1 || false true 
            owner: 0, // object_id_owner || 0 === false
            version: 0, // incremental integer for new patches
            pending: [],
            applied_version: 0, // last patch version applied correctly
            applied: {}
        };
    }

    return object_data;
};




//////////  src/core/protocol/registerOwner.js

dop.core.registerOwner = function(node, object, object_owner_id) {
    var object_data = dop.core.registerObjectToNode(node, object),
        object_id = dop.getObjectId(object_data.object);
    object_data.node[node.token].owner = object_owner_id;
    node.owner[object_owner_id] = object_id;
};




//////////  src/core/protocol/registerSubscriber.js

dop.core.registerSubscriber = function(node, object) {
    var object_data = dop.core.registerObjectToNode(node, object),
        object_id = dop.getObjectId(object_data.object);
    node.subscriber[object_id] = true;
    if (object_data.node[node.token].subscriber)
        return false;
    else {
        object_data.node[node.token].subscriber = 1;
        return true;
    }
};




//////////  src/core/protocol/sendMessages.js

dop.core.sendMessages = function(node) {
    var total = node.message_queue.length;
    if (total>0 && node.connected) {
        var index = 0,
            messages_wrapped = [],
            message_string,
            message,
            request_id;
        
        for (;index<total; ++index) {
            message = node.message_queue[index][0];
            messages_wrapped.push( node.message_queue[index][1](message) );
            request_id = message[0]
            // If is a request (not a response) we set a timeout
            if (request_id>0) {
                var nameinstruction = dop.protocol.instructions[message[1]];
                message.timeout = setTimeout(function() {
                    // if (node.requests[request_id] !== undefined) {
                        dop.protocol['on'+nameinstruction+'timeout'](node, request_id, message);
                        delete node.requests[request_id];
                    // }
                }, dop.protocol.timeouts[nameinstruction]);
            }
        }

        
        message_string = (index>1) ? '['+messages_wrapped.join(',')+']' : messages_wrapped[0];

        node.message_queue = [];
        node.send(message_string);
    }
};




//////////  src/core/protocol/setSocketToNode.js

dop.core.setSocketToNode = function(node, socket) {
    node.socket = socket;
    socket[dop.cons.TOKEN] = node.token;
};




//////////  src/core/protocol/storeMessage.js

dop.core.storeMessage = function(node, message, wrapper) {
    if (typeof wrapper != 'function')
        wrapper = dop.encode;
    node.message_queue.push([message, wrapper]);
};




//////////  src/core/protocol/storeSendMessages.js

dop.core.storeSendMessages = function(node, message, wrapper) {
    dop.core.storeMessage(node, message, wrapper);
    dop.core.sendMessages(node);
};




//////////  src/core/protocol/unregisterNode.js

dop.core.unregisterNode = function(node) {
    var object_id, object_owner_id, object_data;
    // Removing subscriber objects
    for (object_id in node.subscriber) {
        object_data = dop.data.object[object_id];
        if (object_data !== undefined && object_data.node[node.token] !== undefined) {
            object_data.nodes_total -= 1;
            delete object_data.node[node.token];
        }
    }
    // Removing owner objects
    for (object_owner_id in node.owner) {
        object_id = node.owner[object_owner_id];
        object_data = dop.data.object[object_id];
        if (object_data !== undefined && object_data.node[node.token] !== undefined) {
            object_data.nodes_total -= 1;
            delete object_data.node[node.token];
        }
    }
    // Deleting object data if not more nodes are depending
    if (object_data!==undefined && object_data.nodes_total === 0)
        delete dop.data.object[object_id];
    delete dop.data.node[node.token];
};




//////////  src/protocol/_onbroadcast.js

dop.protocol._onbroadcast = function(node, request_id, request, response) {
    dop.protocol._oncall(node, request_id, request, response);
};




//////////  src/protocol/_oncall.js

dop.protocol._oncall = function(node, request_id, request, response) {
    var rejection = response[0],
        promise = request.promise;
    if (rejection !== undefined) {
        if (rejection === 0)
            promise.resolve(response[1]);
        else if (rejection===dop.core.error.reject_remote.CUSTOM_REJECTION)
            promise.reject(response[1]);
        else
            promise.reject(dop.core.getRejectError(rejection));
    }
};




//////////  src/protocol/_onpatch.js

dop.protocol._onpatch = function(node, request_id, request, response) {
    var rejection = response[0],
        object_id = request[2],
        object_node = dop.data.object[object_id].node[node.token],
        version = request[3],
        pending_list = object_node.pending,
        promise = request.promise,
        index = 0,
        total = pending_list.length,
        version_item;


    if (rejection !== undefined) {
        if (rejection === 0) {
            for (;index<total; index++) {
                version_item = pending_list[index][0];
                // Removing from pending because its been received correctly
                if (version_item >= version) {
                    if (version_item === version)
                        pending_list.splice(index, 1);
                    break;
                }
                // Resending
                else
                    dop.protocol.patchSend(node, object_id, version_item, pending_list[index][1]);
            }
            promise.resolve(response[1]);
        }
        else
            promise.reject(dop.core.getRejectError(rejection));
    }
};




//////////  src/protocol/_onsubscribe.js

dop.protocol._onsubscribe = function(node, request_id, request, response) {

    if (response[0] !== undefined) {

        if (response[0] !== 0)
            request.promise.reject(dop.core.getRejectError(response[0]));

        else {
            var object_owner_id = response[1],
                object_owner = response[2],
                object_path = isArray(object_owner) ? object_owner : [],
                object, collector;

            // New object
            if (node.owner[object_owner_id] === undefined) {

                // If is new object and third parameter is an array we must reject
                if (object_owner===object_path)
                    request.promise.reject(dop.core.error.reject_local.OBJECT_NOT_FOUND);

                collector = dop.collect();
                if (dop.isRegistered(request.into))
                    object = dop.core.setPatch(request.into, object_owner, dop.core.setPatchFunctionMutator);
                else
                    object = dop.register((request.into===undefined) ? 
                        object_owner
                    :
                        dop.core.setPatch(request.into, object_owner, dop.core.setPatchMutator)
                    );
                dop.core.registerOwner(node, object, object_owner_id);
                collector.emit();
            }
            // Already registered
            else
                object = dop.data.object[node.owner[object_owner_id]].object;

            object = dop.util.get(object, object_path);

            if (!isObject(object))
                request.promise.reject(dop.core.error.reject_local.OBJECT_NOT_FOUND);
            else
                request.promise.resolve(dop.getObjectProxy(object));
            
        }
    }
};




//////////  src/protocol/_onunsubscribe.js

dop.protocol._onunsubscribe = function(node, request_id, request, response) {

    if (response[0] !== undefined) {
        if (response[0] !== 0)
            request.promise.reject(response[0]);
        else {
            var object_owner_id = request[2],
                object_id = node.owner[object_owner_id],
                object_data = dop.data.object[object_id];

            if (isObject(object_data) && isObject(object_data.node[node.token]) && object_data.node[node.token].owner===object_owner_id) {
                var roles = object_data.node[node.token];
                roles.owner = 0;

                if (roles.subscriber === 0)
                    object_data.nodes_total -= 1;

                if (object_data.nodes_total === 0)
                    delete dop.data.object[object_id];
                
                request.promise.resolve();
            }
        }
    }
};




//////////  src/protocol/broadcast.js

dop.protocol.broadcast = function(object_id, path, params) {

    var object_data = dop.data.object[object_id],
        promises = [];

    if (isObject(object_data) && isObject(object_data.node)) {
        var token, node, request, 
            nodes = object_data.node;
        params = Array.prototype.slice.call(params, 0);
        for (token in nodes) {
            if (nodes[token].subscriber === 1) {
                node = dop.data.node[token];
                request = dop.core.createRequest(
                    node,
                    dop.protocol.instructions.broadcast,
                    object_id,
                    path,
                    params
                );
                request.promise.node = node;
                dop.core.storeSendMessages(node, request);
                promises.push(request.promise);
            }
        }
    }
    
    return promises;
};




//////////  src/protocol/call.js

dop.protocol.call = function(node, object_id, path, params) {

    var object_data = dop.data.object[object_id];

    if (isObject(object_data) && isObject(object_data.node[node.token]) && object_data.node[node.token].owner>0) {
        params = Array.prototype.slice.call(params, 0);
        var request = dop.core.createRequest(
            node,
            dop.protocol.instructions.call,
            object_data.node[node.token].owner,
            path,
            params
        );
        dop.core.storeSendMessages(node, request);
        return request.promise;
    }
    else
        return Promise.reject(dop.core.error.reject_local.NODE_NOT_FOUND);
};




//////////  src/protocol/instructions.js

dop.protocol.instructions = {


    // [<request_id>, <instruction>, <params...>]
    // If <request_id> it's greater than 0 is a request, if is less than 0 then is the response of the request.

    // Is possible send multiple requests in one message, just wrapping it in an Array. But the order of the responses is not determined. Which means the response of request_idTwo could be resolved before request_idOne
    // [[<request_id1>, <instruction>, <params...>], [<request_id2>, <instruction>, <params...>]]

    // Is possible send one request with multiple instructions. The response will be recieved when all the requests are resolved. The response could be only one. But if the response is multiple has to respect the order
    // [<request_id>, [<instruction>, <params...>], [<instruction>, <params...>]]

    // If the response has a 0 as second parameter, means the response it's fulfilled. Any other value is an error
    // [-1234, 0, <params...>]

    // Also the error response could be custom as string
    // [-1234, 'My custom message error']

    // Response with instructions, if the second parameter of the response is an array it means is an instruction that could be (set, delete or merge)
    // [-<request_id>, [<instruction>, <params...>], [<instruction>, <params...>]]

    // Sending the same request without parameters means a cancel/abort of the request
    // [1234]

                        // Subscriber -> Owner
    subscribe: 1,       // [ 1234, <instruction>, <params...>]
                        // [-1234, 0, <object_id>, <data_object>]
                        // [-1234, 0, <object_id>, ['path']]

                        // Subscriber -> Owner
    unsubscribe: 2,     // [ 1234, <instruction>, <object_id>]
                        // [-1234, 0]

                        // Subscriber -> Owner
    call: 3,            // [ 1234, <instruction>, <object_id>, ['path','subpath'], [<params...>]]
                        // [-1234, 0, <return>]

                        // Owner -> Subscriber
    broadcast: 4,       // [ 1234, <instruction>, <object_id>, ['path','subpath'], [<params...>]]
                        // [-1234, 0, <return>]

                        // Owner -> Subscriber
    patch: 5,           // [ 1234, <instruction>, <object_id>, <version>, <patch>]
                        // [-1234, 0]
    


    1: 'subscribe',
    2: 'unsubscribe',
    3: 'call',
    4: 'broadcast',
    5: 'patch'
};

// for (var instruction in dop.protocol.instructions)
    // dop.protocol.instructions[ dop.protocol.instructions[instruction] ] = instruction;




//////////  src/protocol/instructionsPatchs.js

dop.protocol.instructionsPatchs = {
    undefined: '~U', // Delete
    function: '~F', // Remote function
    object: 0, // New object or array
    splice: 1, // Splice array
    swaps: 2, // Swap array

    // Non standards, only for JavaScript
    nan: '~N',
    regex: '~R',
    infinity: '~I',
    _infinity: '~i'
};




// a={
//     a: [0],
//     b: undefined,
//     c: "[0]",
//     newarr: {a:[0],b:undefined,c:"[0]",d:[4,[0],{}]},
// }

// // --------

// b={
//     a: [2,[0]],
//     b: [0],
//     c: "[0]",
//     newarr: [2,{a:[2,[0]],b:[0],c:"[0]",d:[2,[4,[2,[0]],[2,{}]]] }],
// }

// c={
//     a: [2,[0]],
//     b: [0],
//     c: "[0]",
//     newarr: [2,{a:"[0]",b:[0],c:"[[0]",d:[4,[0],{}]}],
// }


// c={
//     a: [2,[0]],
//     b: "~U",
//     c: "[0]",
//     newarr: [2,{a:[0],b:"~U",c:"[0]",d:[4,[0],{}]}],
// }





//////////  src/protocol/onbroadcast.js

dop.protocol.onbroadcast = function(node, request_id, request) {
    dop.protocol.onfunction(node, request_id, request, node.owner[request[1]], function(permission) {
        return permission.owner===request[1];
    });
};




//////////  src/protocol/oncall.js

dop.protocol.oncall = function(node, request_id, request) {
    dop.protocol.onfunction(node, request_id, request, request[1], function(permission) {
        return permission.subscriber===1;
    });
}




//////////  src/protocol/onfunction.js
// Used by dop.protocol.oncall && dop.protocol.onbroadcast
dop.protocol.onfunction = function(node, request_id, request, object_id, validator) {
    var path = request[2],
        params = request[3],
        object_data = dop.data.object[object_id];

    if (isObject(object_data) && isObject(object_data.node[node.token]) && validator(object_data.node[node.token])) {
        var functionName = path.pop(),
            object = dop.util.get(object_data.object, path),
            f = object[functionName];
        if (isFunction(f) && !dop.isBroadcastFunction(f)) {
            function resolve(value) {
                var response = dop.core.createResponse(request_id, 0);
                if (value !== undefined)
                    response.push(value);
                dop.core.storeSendMessages(node, response);
                return value;
            }
            function reject(err){
                dop.core.storeSendMessages(node, dop.core.createResponse(request_id, dop.core.error.reject_remote.CUSTOM_REJECTION, err));
            }

            if (dop.isRemoteFunction(f))
                f.apply(null, params).then(resolve).catch(reject);
            else
                dop.core.localProcedureCall(f, params, resolve, reject, function(req) {
                    req.node = node;
                    return req;
                }, dop.getObjectProxy(object));

            return;
        }
    }
    
    dop.core.storeSendMessages(node, dop.core.createResponse(request_id, dop.core.error.reject_remote.FUNCTION_NOT_FOUND));
};




//////////  src/protocol/onpatch.js

dop.protocol.onpatch = function(node, request_id, request) {
    var object_id_owner = request[1],
        object_id = node.owner[object_id_owner],
        version = request[2],
        patch = request[3],
        response = dop.core.createResponse(request_id),
        object_data = dop.data.object[object_id],
        object_node,
        collector;
    
    if (isObject(object_data) && isObject(object_data.node[node.token]) && object_data.node[node.token].owner===object_id_owner) {
        object_node = object_data.node[node.token];
        // Storing patch
        if (object_node.applied_version < version && object_node.applied[version]===undefined) {
            // Storing patch
            object_node.applied[version] = patch;
            // Applying
            collector = dop.collect();
            while (object_node.applied[object_node.applied_version+1]) {
                object_node.applied_version += 1;
                dop.core.setPatch(
                    object_data.object,
                    object_node.applied[object_node.applied_version],
                    dop.core.setPatchFunctionMutator
                );
                delete object_node.applied[object_node.applied_version];
            }
            collector.emit();
        }
        response.push(0);
    }
    else
        response.push(dop.core.error.reject_remote.OBJECT_NOT_FOUND);
    
    dop.core.storeSendMessages(node, response);
};




//////////  src/protocol/onpatchtimeout.js

dop.protocol.onpatchtimeout = function(node, request_id, request) {
    dop.protocol.patchSend(node, request[2], request[3], request[4]);
};




//////////  src/protocol/onsubscribe.js

dop.protocol.onsubscribe = function(node, request_id, request) {

    if (isFunction(dop.data.onsubscribe)) {

        var params = Array.prototype.slice.call(request, 1);

        dop.core.localProcedureCall(dop.data.onsubscribe, params, function resolve(value) {
            if (dop.isPojoObject(value)) {
                var object = dop.register(value),
                    object_root = dop.getObjectRoot(object),
                    object_path = dop.getObjectPath(object),
                    object_id = object_path[0],
                    response = dop.core.createResponse(request_id, 0);

                // New object
                if (dop.core.registerSubscriber(node, object_root))
                    response.push(object_id, object_root);

                // Object already subscribed
                else
                    response.push(object_id, object_path.slice(1));

                dop.core.storeSendMessages(node, response, dop.encodeFunction);
                return object;
            }
            else if (value === undefined)
                return Promise.reject(dop.core.error.reject_remote.OBJECT_NOT_FOUND);
            else
                // http://www.2ality.com/2016/03/promise-rejections-vs-exceptions.html
                // http://stackoverflow.com/questions/41254636/catch-an-error-inside-of-promise-resolver
                dop.util.invariant(false, 'dop.onsubscribe callback must return or resolve a regular object');


        }, reject, function(req) {
            req.node = node;
            return req;
        });

    }
    else
        reject(dop.core.error.reject_remote.OBJECT_NOT_FOUND);

    function reject(error) {
        var response = dop.core.createResponse(request_id);
        (error instanceof Error) ? console.log(error.stack) : response.push(error);
        dop.core.storeSendMessages(node, response, JSON.stringify);
    }
};




//////////  src/protocol/ontimeout.js
dop.protocol.onsubscribetimeout = 
dop.protocol.onunsubscribetimeout = 
dop.protocol.oncalltimeout = 
dop.protocol.onbroadcasttimeout = function(node, request_id, request) {
    request.promise.reject(dop.core.error.reject_local.TIMEOUT_REQUEST);
};




//////////  src/protocol/onunsubscribe.js

dop.protocol.onunsubscribe = function(node, request_id, request) {
    var object_id = request[1],
        object_data = dop.data.object[object_id],
        response = dop.core.createResponse(request_id);

    if (isObject(object_data) && isObject(object_data.node[node.token]) && object_data.node[node.token].subscriber) {
        
        var roles = object_data.node[node.token];
        roles.subscriber = 0;

        if (roles.owner === 0)
            object_data.nodes_total -= 1;

        if (object_data.nodes_total === 0)
            delete dop.data.object[object_id];

        response.push(0);
    }
    else
        response.push(dop.core.error.reject_remote.SUBSCRIPTION_NOT_FOUND);

    dop.core.storeSendMessages(node, response);
};




//////////  src/protocol/patch.js

dop.protocol.patch = function(node, object_id, patch) {
    var object_node = dop.data.object[object_id].node[node.token],
        version = ++object_node.version;
    object_node.pending.push([version, dop.util.merge({}, patch)]); // Making a copy because this object is exposed to the api users and can be mutated
    return dop.protocol.patchSend(node, object_id, version, patch);
};

// Also used by dop.protocol._onpatch
dop.protocol.patchSend = function(node, object_id, version, patch) {
    var request = dop.core.createRequest( node, dop.protocol.instructions.patch, object_id, version, patch);
    dop.core.storeSendMessages(node, request, dop.encodeFunction);
    return request.promise;
};




//////////  src/protocol/subscribe.js

dop.protocol.subscribe = function(node, params) {
    params = Array.prototype.slice.call(params, 0);
    params.unshift(node, dop.protocol.instructions.subscribe);
    var request = dop.core.createRequest.apply(node, params);
    request.promise.into = function(object) {
        if (dop.isPojoObject(object))
            request.into = (dop.isRegistered(object)) ? dop.getObjectProxy(object) : object;
        delete request.promise.into
        return request.promise;
    };
    dop.core.storeSendMessages(node, request);
    return request.promise;
};




//////////  src/protocol/timeouts.js
// Default timeouts
dop.protocol.timeouts = {
    subscribe: 5000,
    unsubscribe: 5000,
    call: 10000,  
    broadcast: 10000,
    patch: 1000    
};




//////////  src/protocol/unsubscribe.js

dop.protocol.unsubscribe = function(node, object) {
    var object_id = dop.getObjectId(object),
        object_data = dop.data.object[object_id];

    if (isObject(object_data) && isObject(object_data.node[node.token]) && object_data.node[node.token].owner>0) {
        var request = dop.core.createRequest(
            node,
            dop.protocol.instructions.unsubscribe,
            object_data.node[node.token].owner
        );
        dop.core.storeSendMessages(node, request);
        return request.promise;
    }
    else
        return Promise.reject(dop.core.error.reject_remote[2]);
};





//////////  src/umd.js
// Factory
if (root === undefined)
    return dop;

// AMD
if (typeof define === 'function' && define.amd)
    define([], function() { return dop });

// Node
else if (typeof module == 'object' && module.exports)
    module.exports = dop;

// Browser
else if (typeof window == 'object' && window)
    window.dop = dop;

else
    root.dop = dop;

})(this);


